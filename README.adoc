= gRPC to REST Gateway

gRPC to REST gateway generates a reverse-proxy server which converts REST HTTP API into gRPC. This project is based on work done by https://github.com/btlines/grpcgateway[grpcgateway].

== About this project

This project has two main modules, namely `grpc-rest-gateway-runtime` and `grpc-rest-gateway-code-gen`.

=== Runtime library &mdash; `grpc-rest-gateway-runtime`

Following are main classes in runtime library:

. `GrpcGatewayHandler` &mdash; base abstract class responsible for dispatch given HTTP call to corresponding function in gRPC service.
. `SwaggerHandler` &mdash; responsible for Open API yaml files and generate Swagger UI.
. Server classes to build REST server and transform gRPC response HTTP response.

=== Code generation library &mdash; `grpc-rest-gateway-code-gen`

Code generation library is responsible for reading given Protobuf files and generating corresponding implementation of `GrpcGatewayHandler`.

For example following Protobuf definition:

[source, protobuf]
----
syntax = "proto3";

package rest_gateway_test.api;

import "scalapb/scalapb.proto";
import "google/api/annotations.proto";
import "common.proto";

option java_multiple_files = false;
option java_package = "rest_gateway_test.api.java_api";
option java_outer_classname = "TestServiceBProto";
option objc_class_prefix = "TS2P";

option (scalapb.options) = {
  single_file: true
  lenses: true
  retain_source_code_info: true
  preserve_unknown_fields: false
  package_name: "rest_gateway_test.api.scala_api"
};

service TestServiceB {
  rpc GetRequest (rest_gateway_test.api.model.TestRequestB) returns (rest_gateway_test.api.model.TestResponseB) {
    option (google.api.http) = {
      get: "/restgateway/test/testserviceb"
    };
  }

  rpc Process (rest_gateway_test.api.model.TestRequestB) returns (rest_gateway_test.api.model.TestResponseB) {
    option (google.api.http) = {
      post: "/restgateway/test/testserviceb"
      body: "*"
    };
  }
}
----

will generate following implementation of `GrpcGatewayHandler` and Open API specification respectively:

[source, scala]
----
package rest_gateway_test.api.scala_api.TestServiceB

import _root_.scalapb.GeneratedMessage
import _root_.scalapb.json4s.JsonFormat
import _root_.com.improving.grpc_rest_gateway.runtime.handlers._
import _root_.io.grpc._
import _root_.io.netty.handler.codec.http.{HttpMethod, QueryStringDecoder}

import scala.jdk.CollectionConverters._
import scala.concurrent.{ExecutionContext, Future}
import scalapb.json4s.JsonFormatException
import scala.util._

class TestServiceBGatewayHandler(channel: ManagedChannel)(implicit ec: ExecutionContext)
  extends GrpcGatewayHandler(channel)(ec) {
  override val name: String = "TestServiceB"
  private val stub = TestServiceBGrpc.stub(channel)

  override def supportsCall(method: HttpMethod, uri: String): Boolean = {
    val queryString = new QueryStringDecoder(uri)
    (method.name, queryString.path) match {
      case ("GET", "/restgateway/test/testserviceb") => true
      case ("POST", "/restgateway/test/testserviceb") => true
      case _ => false
    }
  }

  override def unaryCall(method: HttpMethod, uri: String, body: String): Future[GeneratedMessage] = {
    val queryString = new QueryStringDecoder(uri)
    (method.name, queryString.path) match {
      case ("GET", "/restgateway/test/testserviceb") =>
        val input = Try {
          val requestId =
            queryString.parameters().get("requestId").asScala.head.toLong
          rest_gateway_test.api.model.common.TestRequestB(requestId = requestId)
        }
        Future.fromTry(input).flatMap(stub.getRequest)
      case ("POST", "/restgateway/test/testserviceb") =>
      for {
        msg <- Future.fromTry(Try(JsonFormat.fromJsonString[rest_gateway_test.api.model.common.TestRequestB](body)).recoverWith(jsonException2GatewayExceptionPF))
        res <- stub.process(msg)
      } yield res
      case (methodName, path) =>
        Future.failed(InvalidArgument(s"No route defined for $methodName($path)"))
    }
  }
}
----

[source, yaml]
----
swagger: '2.0'
info:
  version: 0.1.0-SNAPSHOT
  title: 'rest_gateway_test.api.scala_api.TestServiceB.TestServiceBProto'
  description: 'REST API generated from TestServiceB'
schemes:
  - http
  - https
consumes:
  - 'application/json'
produces:
  - 'application/json'
paths:
  /restgateway/test/testserviceb:
    get:
      tags:
        - TestServiceB
      summary:
        'GetRequest'
      description:
        'Generated from rest_gateway_test.api.TestServiceB.GetRequest'
      produces:
        ['application/json']
      responses:
        200:
          description: 'Normal response'
          schema:
            $ref: "#/definitions/TestResponseB"
      parameters:
      - name: requestId
        in: query
        type: integer
        format: int64
    post:
      tags:
        - TestServiceB
      summary:
        'Process'
      description:
        'Generated from rest_gateway_test.api.TestServiceB.Process'
      produces:
        ['application/json']
      responses:
        200:
          description: 'Normal response'
          schema:
            $ref: "#/definitions/TestResponseB"
      parameters:
        - in: 'body'
          name: body
          schema:
            $ref: "#/definitions/TestRequestB"
definitions:
  TestRequestB:
    type: object
    properties:
      requestId:
        type: integer
        format: int64
  TestResponseB:
    type: object
    properties:
      success:
        type: boolean
      request_id:
        type: integer
        format: int64
      result:
        type: string
----

=== Run gateway server

Implement your gRPC services as per your need and run gRPC server. Gateway server can be build and run as follows:

[source, scala]
----
import com.improving.grpc_rest_gateway.runtime.server.GatewayServer
import rest_gateway_test.api.scala_api.TestServiceB.TestServiceBGatewayHandler
import scala.concurrent.ExecutionContext

implicit val ex: ExecutionContext = ??? // provide ExecutionContext
val server = GatewayServer(
      serviceHost = "localhost",
      servicePort = 8080, // assuming gRPC server is running on port 8080
      gatewayPort = 7070, // REST end point is running at port 7070
      toHandlers = channel =>
        Seq(new TestServiceBGatewayHandler(channel)),
      executor = None // Executor is useful if you want to allocate different thread pool for REST endpoint
    )
server.start()

// stop server once done
server.stop()
----

=== Set up your project

TBD

=== Run tests and sample app

`e2e` module contains test code and a sample app.

Tests can be run as follows:

[source, shell]
----
sbt "e2e / test"
----

Sample app can be run as follows:

[source, shell]
----
sbt "e2e / run"
----

Open browser and paste following URL in address bar `http://localhost:7070/docs/index.html?urls.primaryName=TestServiceB#/`, you should see Open API specification for service.

image::media/swagger.png[]

== Limitations

. Streaming calls are not supported.
. Get calls with parameters only are supported (no path parameters), i.e., `/my_service?my_param=abc` is supported, following call will fail `/my_servic/abc`.
