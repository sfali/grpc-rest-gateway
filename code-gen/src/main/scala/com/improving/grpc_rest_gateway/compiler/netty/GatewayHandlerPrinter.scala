package com.improving
package grpc_rest_gateway
package compiler
package netty

import com.google.api.{AnnotationsProto, HttpRule}
import com.google.api.HttpRule.PatternCase
import com.google.protobuf.Descriptors.{MethodDescriptor, ServiceDescriptor}
import com.google.protobuf.compiler.PluginProtos.CodeGeneratorResponse
import com.improving.grpc_rest_gateway.compiler.utils.{Formatter, GenerateDelegateFunctions, GenerateImportStatements}
import scalapb.compiler.FunctionalPrinter.PrinterEndo
import scalapb.compiler.{DescriptorImplicits, FunctionalPrinter, NameUtils}

import scala.jdk.CollectionConverters.*

class GatewayHandlerPrinter(service: ServiceDescriptor, implicits: DescriptorImplicits) extends HandlerPrinter {
  import implicits.*

  private var ifStatementStarted = false
  private var pathsToConstantMap: Map[(PatternCase, String), String] = Map.empty
  private val extendedFileDescriptor = ExtendedFileDescriptor(service.getFile)
  private val serviceName = service.getName
  private val specificationName = getProtoFileName(extendedFileDescriptor.file.getName)
  private val scalaPackageName = extendedFileDescriptor.scalaPackage.fullName
  private val handlerClassName = serviceName + "GatewayHandler"
  private val outputFileName = scalaPackageName.replace('.', '/') + "/" + handlerClassName + ".scala"
  private val wildcardImport = extendedFileDescriptor.V.WildcardImport
  private val methods = getUnaryCallsWithHttpExtension(service).toList

  lazy val content: String =
    new FunctionalPrinter()
      .add("/*", " * Generated by GRPC-REST gateway compiler. DO NOT EDIT.", " */")
      .add(s"package $scalaPackageName")
      .newline
      .add(
        "import scalapb.GeneratedMessage",
        "import io.grpc.ManagedChannel",
        "import io.netty.handler.codec.http.{HttpMethod, QueryStringDecoder}"
      )
      .newline
      .add(
        s"import com.improving.grpc_rest_gateway.runtime",
        s"import runtime.core.$wildcardImport",
        s"import runtime.handlers.$wildcardImport"
      )
      .call(GenerateImportStatements(scalaPackageName, implicits, methods))
      .newline
      .add(
        "import scala.concurrent.{ExecutionContext, Future}",
        "import scala.util.Try"
      )
      .newline
      .call(generateCompanionObject)
      .newline
      .print(Seq(service)) { case (p, s) => generateService(s)(p) }
      .result()

  override val result: CodeGeneratorResponse.File = {
    val b = CodeGeneratorResponse.File.newBuilder()
    b.setName(outputFileName)
    b.setContent(Formatter.format(content))
    b.build()
  }

  private def generateCompanionObject: PrinterEndo = { printer =>
    val paths =
      methods.filter(_.getOptions.hasExtension(AnnotationsProto.http)).flatMap { method =>
        val uppercaseMethodName = NameUtils.snakeCaseToCamelCase(method.getName, upperInitial = true)
        val paths = extractPaths(method)
        if (paths.size == 1) {
          val (patternCase, path, _) = paths.head
          val constantName =
            s"${NameUtils.snakeCaseToCamelCase(patternCase.name().toLowerCase, upperInitial = true)}${uppercaseMethodName}Path"
          pathsToConstantMap = pathsToConstantMap + ((patternCase, path) -> constantName)
          Seq(s"""private val $constantName = "$path"""")
        } else
          paths.zipWithIndex.map { case ((patternCase, path, _), index) =>
            val constantName =
              s"${NameUtils.snakeCaseToCamelCase(patternCase.name().toLowerCase, upperInitial = true)}${uppercaseMethodName}Path${index + 1}"
            pathsToConstantMap = pathsToConstantMap + ((patternCase, path) -> constantName)
            s"""private val $constantName = "$path""""
          }
      }
    printer
      .add(s"object $handlerClassName {")
      .indent
      .seq(paths)
      .outdent
      .newline
      .indent
      .add(s"def apply(channel: ManagedChannel)(implicit ec: ExecutionContext): $handlerClassName = ")
      .indent
      .add(s"new $handlerClassName(channel)")
      .outdent
      .outdent
      .add("}")
  }

  private def generateService(service: ServiceDescriptor): PrinterEndo = { printer =>
    val descriptor = ExtendedServiceDescriptor(service)
    // this is NOT the FQN of the service, we are generating gateway handler in the same package as GRPC service
    val grpcService = descriptor.companionObject.name
    printer
      .add(s"class $handlerClassName(channel: ManagedChannel)(implicit ec: ExecutionContext)")
      .indent
      .add(
        "extends GrpcGatewayHandler(channel)(ec) {",
        s"import $handlerClassName.$wildcardImport",
        s"""override val serviceName: String = "${service.getName}"""",
        s"""override val specificationName: String = "$specificationName"""",
        s"private lazy val client = $grpcService.stub(channel)"
      )
      .call(generateHttpMethodToUrisMap)
      .newline
      .call(generateDispatchCall)
      .outdent
      .newline
      .call(GenerateDelegateFunctions(implicits, "toResponse", methods))
      .add("}")
  }

  private def generateDispatchCall: PrinterEndo =
    _.add(
      s"override protected def dispatchCall(method: HttpMethod, uri: String, body: String): Future[GeneratedMessage] = {"
    )
      .indent
      .add(
        "val queryString = new QueryStringDecoder(uri)",
        "val path = queryString.path",
        "val methodName = method.name"
      )
      .call(generateMethodHandlers)
      .outdent
      .add("}")

  private def generateMethodHandlers: PrinterEndo = { printer =>
    val p =
      methods.foldLeft(printer) { case (printer, method) =>
        val http = method.getOptions.getExtension(AnnotationsProto.http)
        val bindings = http +: http.getAdditionalBindingsList.asScala
        bindings.foldLeft(printer) { case (printer, httpRule) =>
          generateMethodHandler(method, httpRule)(printer)
        }
      }

    if (ifStatementStarted)
      p.add(s"""else Future.failed(GatewayException.toInvalidArgument(s"No route defined for $$methodName($$path)"))""")
    else p
  }

  private def generateMethodHandler(method: MethodDescriptor, http: HttpRule): PrinterEndo = { printer =>
    val body = http.getBody
    val delegateFunctionName = GenerateDelegateFunctions.generateDelegateFunctionName(method.getName)
    http.getPatternCase match {
      case PatternCase.GET =>
        val constantName = pathsToConstantMap((PatternCase.GET, http.getGet))
        val p1 =
          if (ifStatementStarted)
            printer.add(s"""else if (isSupportedCall(HttpMethod.GET.name, $constantName, methodName, path))""")
          else {
            ifStatementStarted = true
            printer.add(s"""if (isSupportedCall(HttpMethod.GET.name, $constantName, methodName, path))""")
          }
        p1.indent.add(s"$delegateFunctionName(mergeParameters($constantName, queryString))").outdent

      case PatternCase.PUT =>
        val constantName = pathsToConstantMap((PatternCase.PUT, http.getPut))
        val p1 =
          if (ifStatementStarted)
            printer.add(s"""else if (isSupportedCall(HttpMethod.PUT.name, $constantName, methodName, path))""")
          else {
            ifStatementStarted = true
            printer.add(s"""if (isSupportedCall(HttpMethod.PUT.name, $constantName, methodName, path))""")
          }
        p1.indent
          .when(body == "*")(_.add(s"$delegateFunctionName(body)"))
          .when(body != "*")(_.add(s"$delegateFunctionName(body, mergeParameters($constantName, queryString))"))
          .outdent

      case PatternCase.POST =>
        val constantName = pathsToConstantMap((PatternCase.POST, http.getPost))

        val p1 =
          if (ifStatementStarted)
            printer.add(s"""else if (isSupportedCall(HttpMethod.POST.name, $constantName, methodName, path))""")
          else {
            ifStatementStarted = true
            printer.add(s"""if (isSupportedCall(HttpMethod.POST.name, $constantName, methodName, path))""")
          }
        p1.indent
          .when(body == "*")(_.add(s"$delegateFunctionName(body)"))
          .when(body != "*")(_.add(s"$delegateFunctionName(body, mergeParameters($constantName, queryString))"))
          .outdent

      case PatternCase.DELETE =>
        val constantName = pathsToConstantMap((PatternCase.DELETE, http.getDelete))
        val p1 =
          if (ifStatementStarted)
            printer.add(s"""else if (isSupportedCall(HttpMethod.DELETE.name, $constantName, methodName, path))""")
          else {
            ifStatementStarted = true
            printer.add(s"""if (isSupportedCall(HttpMethod.DELETE.name, $constantName", methodName, path))""")
          }
        p1.indent.add(s"$delegateFunctionName(mergeParameters($constantName, queryString))").outdent

      case PatternCase.PATCH =>
        val constantName = pathsToConstantMap((PatternCase.PATCH, http.getPatch))
        val p1 =
          if (ifStatementStarted)
            printer.add(s"""else if (isSupportedCall(HttpMethod.PATCH.name, $constantName, methodName, path))""")
          else {
            ifStatementStarted = true
            printer.add(s"""if (isSupportedCall(HttpMethod.PATCH.name, $constantName, methodName, path))""")
          }
        p1.indent.add(s"$delegateFunctionName(mergeParameters($constantName, queryString))").outdent

      case _ => printer
    }
  }

  private def generateHttpMethodToUrisMap: PrinterEndo = { printer =>
    val httpMethodsToUrisMap =
      pathsToConstantMap.foldLeft(Map.empty[PatternCase, Seq[String]]) { case (result, ((patternCase, _), value)) =>
        val updatedValues =
          result.get(patternCase) match {
            case Some(values) => values :+ value
            case None         => Seq(value)
          }
        result + (patternCase -> updatedValues)
      }

    // generate key value pair for the map
    val mapKeys =
      httpMethodsToUrisMap.zipWithIndex.foldLeft(Seq.empty[String]) { case (result, ((methodName, cons), index)) =>
        val pathConstantsSeq = s"""Seq(${cons.sorted.map(uri => " \n" + "  " + uri).mkString(", ")}\n)"""
        // each element of seq is separated by "," except for last element
        val keys = if (index == httpMethodsToUrisMap.size - 1) pathConstantsSeq else s"""$pathConstantsSeq,"""
        result :+ s""""$methodName" -> $keys"""
      }

    printer
      .add("override protected val httpMethodsToUrisMap: Map[String, Seq[String]] = Map(")
      .indent
      .seq(mapKeys)
      .outdent
      .add(")")
  }
}
